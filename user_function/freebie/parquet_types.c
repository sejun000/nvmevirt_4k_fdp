/*
 * `parquet_types.h` is autogenerated by Thrift Compiler (0.22.0).
 * The only changes in the file is deletion of unused functions.
 */
#include "parquet_types.h"
#include "gobject-type.h"
#include "thrift.h"
#include "gmem.h"
#include "thrift_file_transport.h"

static gint64 elem_i64_read;
static Encoding elem_encoding_read;
static gboolean elem_bool_read;

/* reads a size_statistics object */
gint32
size_statistics_read (ThriftStruct *object, ThriftProtocol *protocol,
                      GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SizeStatistics * this_object = SIZE_STATISTICS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype,
                                                 &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->unencoded_byte_array_data_bytes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_unencoded_byte_array_data_bytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          if (this_object->repetition_level_histogram == NULL)
            this_object->repetition_level_histogram = g_array_new (0, 1, sizeof (gint64));
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem0 = &elem_i64_read;
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->repetition_level_histogram, _elem0, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_repetition_level_histogram = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          if (this_object->definition_level_histogram == NULL)
            this_object->definition_level_histogram = g_array_new (0, 1, sizeof (gint64));
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem1 = &elem_i64_read;
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem1, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->definition_level_histogram, _elem1, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_definition_level_histogram = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
size_statistics_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SizeStatistics * this_object = SIZE_STATISTICS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SizeStatistics", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_unencoded_byte_array_data_bytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "unencoded_byte_array_data_bytes", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->unencoded_byte_array_data_bytes, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_repetition_level_histogram == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_level_histogram", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i2;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->repetition_level_histogram ? this_object->repetition_level_histogram->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i2 = 0; i2 < (this_object->repetition_level_histogram ? this_object->repetition_level_histogram->len : 0); i2++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->repetition_level_histogram, gint64, i2)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_definition_level_histogram == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "definition_level_histogram", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i3;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->definition_level_histogram ? this_object->definition_level_histogram->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i3 = 0; i3 < (this_object->definition_level_histogram ? this_object->definition_level_histogram->len : 0); i3++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->definition_level_histogram, gint64, i3)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
size_statistics_instance_init (SizeStatistics * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->unencoded_byte_array_data_bytes = 0;
  object->__isset_unencoded_byte_array_data_bytes = FALSE;
  object->repetition_level_histogram = NULL;
  object->__isset_repetition_level_histogram = FALSE;
  object->definition_level_histogram = NULL;
  object->__isset_definition_level_histogram = FALSE;
}

void
size_statistics_finalize (GObject *object)
{
  SizeStatistics *tobject = SIZE_STATISTICS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->repetition_level_histogram != NULL)
  {
    g_array_unref (tobject->repetition_level_histogram);
    tobject->repetition_level_histogram = NULL;
  }
  if (tobject->definition_level_histogram != NULL)
  {
    g_array_unref (tobject->definition_level_histogram);
    tobject->definition_level_histogram = NULL;
  }
}

GType
size_statistics_get_type (void)
{
  return G_TYPE_SIZE_STATISTICS;
}

/* reads a statistics object */
gint32
statistics_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Statistics * this_object = STATISTICS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->max != NULL)
          {
            g_free(this_object->max);
            this_object->max = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->max == NULL)
            this_object->max = g_byte_array_new();
          g_byte_array_append (this_object->max, (guint8 *) data, (guint) len);
          this_object->__isset_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->min != NULL)
          {
            g_free(this_object->min);
            this_object->min = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->min == NULL)
            this_object->min = g_byte_array_new();
          g_byte_array_append (this_object->min, (guint8 *) data, (guint) len);
          this_object->__isset_min = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->null_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_null_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->distinct_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_distinct_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->max_value != NULL)
          {
            g_free(this_object->max_value);
            this_object->max_value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->max_value == NULL)
            this_object->max_value = g_byte_array_new();
          g_byte_array_append (this_object->max_value, (guint8 *) data, (guint) len);
          this_object->__isset_max_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->min_value != NULL)
          {
            g_free(this_object->min_value);
            this_object->min_value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->min_value == NULL)
            this_object->min_value = g_byte_array_new();
          g_byte_array_append (this_object->min_value, (guint8 *) data, (guint) len);
          this_object->__isset_min_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_max_value_exact, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_max_value_exact = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_min_value_exact, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_min_value_exact = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
statistics_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Statistics * this_object = STATISTICS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Statistics", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_max == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "max", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->max ? ((GByteArray *) this_object->max)->data : NULL, this_object->max ? ((GByteArray *) this_object->max)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_min == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "min", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->min ? ((GByteArray *) this_object->min)->data : NULL, this_object->min ? ((GByteArray *) this_object->min)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_null_count == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "null_count", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->null_count, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_distinct_count == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "distinct_count", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->distinct_count, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_max_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "max_value", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->max_value ? ((GByteArray *) this_object->max_value)->data : NULL, this_object->max_value ? ((GByteArray *) this_object->max_value)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_min_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "min_value", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->min_value ? ((GByteArray *) this_object->min_value)->data : NULL, this_object->min_value ? ((GByteArray *) this_object->min_value)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_is_max_value_exact == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "is_max_value_exact", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->is_max_value_exact, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_is_min_value_exact == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "is_min_value_exact", T_BOOL, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->is_min_value_exact, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
statistics_instance_init (Statistics * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->max = NULL;
  object->__isset_max = FALSE;
  object->min = NULL;
  object->__isset_min = FALSE;
  object->null_count = 0;
  object->__isset_null_count = FALSE;
  object->distinct_count = 0;
  object->__isset_distinct_count = FALSE;
  object->max_value = NULL;
  object->__isset_max_value = FALSE;
  object->min_value = NULL;
  object->__isset_min_value = FALSE;
  object->is_max_value_exact = 0;
  object->__isset_is_max_value_exact = FALSE;
  object->is_min_value_exact = 0;
  object->__isset_is_min_value_exact = FALSE;
}

void
statistics_finalize (GObject *object)
{
  Statistics *tobject = STATISTICS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->max != NULL)
  {
    thrift_string_free(tobject->max);
    tobject->max = NULL;
  }
  if (tobject->min != NULL)
  {
    thrift_string_free(tobject->min);
    tobject->min = NULL;
  }
  if (tobject->max_value != NULL)
  {
    thrift_string_free(tobject->max_value);
    tobject->max_value = NULL;
  }
  if (tobject->min_value != NULL)
  {
    thrift_string_free(tobject->min_value);
    tobject->min_value = NULL;
  }
}

GType
statistics_get_type (void)
{
  return G_TYPE_STATISTICS;
}

/* reads a string_type object */
gint32
string_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  StringType * this_object = STRING_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
string_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  StringType * this_object = STRING_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StringType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
string_type_instance_init (StringType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
string_type_finalize (GObject *object)
{
  StringType *tobject = STRING_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
string_type_get_type (void)
{
  return G_TYPE_STRING_TYPE;
}

/* reads a u_u_i_d_type object */
gint32
u_u_i_d_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UUIDType * this_object = U_U_I_D_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
u_u_i_d_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UUIDType * this_object = U_U_I_D_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UUIDType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
u_u_i_d_type_instance_init (UUIDType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
u_u_i_d_type_finalize (GObject *object)
{
  UUIDType *tobject = U_U_I_D_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
u_u_i_d_type_get_type (void)
{
  return G_TYPE_U_U_I_D_TYPE;
}

/* reads a map_type object */
gint32
map_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MapType * this_object = MAP_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
map_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MapType * this_object = MAP_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MapType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
map_type_instance_init (MapType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
map_type_finalize (GObject *object)
{
  MapType *tobject = MAP_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
map_type_get_type (void)
{
  return G_TYPE_MAP_TYPE;
}

/* reads a list_type object */
gint32
list_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ListType * this_object = LIST_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
list_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ListType * this_object = LIST_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
list_type_instance_init (ListType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
list_type_finalize (GObject *object)
{
  ListType *tobject = LIST_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
list_type_get_type (void)
{
  return G_TYPE_LIST_TYPE;
}

/* reads a enum_type object */
gint32
enum_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EnumType * this_object = ENUM_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
enum_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EnumType * this_object = ENUM_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EnumType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
enum_type_instance_init (EnumType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
enum_type_finalize (GObject *object)
{
  EnumType *tobject = ENUM_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
enum_type_get_type (void)
{
  return G_TYPE_ENUM_TYPE;
}

/* reads a date_type object */
gint32
date_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DateType * this_object = DATE_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
date_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DateType * this_object = DATE_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DateType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
date_type_instance_init (DateType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
date_type_finalize (GObject *object)
{
  DateType *tobject = DATE_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
date_type_get_type (void)
{
  return G_TYPE_DATE_TYPE;
}

/* reads a float16_type object */
gint32
float16_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Float16Type * this_object = FLOAT16_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
float16_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Float16Type * this_object = FLOAT16_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Float16Type", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
float16_type_instance_init (Float16Type * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
float16_type_finalize (GObject *object)
{
  Float16Type *tobject = FLOAT16_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
float16_type_get_type (void)
{
  return G_TYPE_FLOAT16_TYPE;
}

/* reads a null_type object */
gint32
null_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NullType * this_object = NULL_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
null_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NullType * this_object = NULL_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NullType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
null_type_instance_init (NullType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
null_type_finalize (GObject *object)
{
  NullType *tobject = NULL_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
null_type_get_type (void)
{
  return G_TYPE_NULL_TYPE;
}

/* reads a decimal_type object */
gint32
decimal_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DecimalType * this_object = DECIMAL_TYPE(object);
  gboolean isset_scale = FALSE;
  gboolean isset_precision = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->scale, error)) < 0)
            return -1;
          xfer += ret;
          isset_scale = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->precision, error)) < 0)
            return -1;
          xfer += ret;
          isset_precision = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_scale)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_precision)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
decimal_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DecimalType * this_object = DECIMAL_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DecimalType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "scale", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->scale, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "precision", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->precision, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
decimal_type_instance_init (DecimalType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->scale = 0;
  object->precision = 0;
}

void
decimal_type_finalize (GObject *object)
{
  DecimalType *tobject = DECIMAL_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
decimal_type_get_type (void)
{
  return G_TYPE_DECIMAL_TYPE;
}

/* reads a milli_seconds object */
gint32
milli_seconds_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MilliSeconds * this_object = MILLI_SECONDS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
milli_seconds_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MilliSeconds * this_object = MILLI_SECONDS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MilliSeconds", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
milli_seconds_instance_init (MilliSeconds * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
milli_seconds_finalize (GObject *object)
{
  MilliSeconds *tobject = MILLI_SECONDS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
milli_seconds_get_type (void)
{
  return G_TYPE_MILLI_SECONDS;
}

/* reads a micro_seconds object */
gint32
micro_seconds_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MicroSeconds * this_object = MICRO_SECONDS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
micro_seconds_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MicroSeconds * this_object = MICRO_SECONDS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MicroSeconds", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
micro_seconds_instance_init (MicroSeconds * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
micro_seconds_finalize (GObject *object)
{
  MicroSeconds *tobject = MICRO_SECONDS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
micro_seconds_get_type (void)
{
  return G_TYPE_MICRO_SECONDS;
}

/* reads a nano_seconds object */
gint32
nano_seconds_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NanoSeconds * this_object = NANO_SECONDS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
nano_seconds_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NanoSeconds * this_object = NANO_SECONDS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NanoSeconds", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
nano_seconds_instance_init (NanoSeconds * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
nano_seconds_finalize (GObject *object)
{
  NanoSeconds *tobject = NANO_SECONDS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
nano_seconds_get_type (void)
{
  return G_TYPE_NANO_SECONDS;
}

/* reads a time_unit object */
gint32
time_unit_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimeUnit * this_object = TIME_UNIT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->MILLIS == NULL)
            this_object->MILLIS = g_object_new (TYPE_MILLI_SECONDS, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->MILLIS), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_MILLIS = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if (this_object->MICROS == NULL)
            this_object->MICROS = g_object_new (TYPE_MICRO_SECONDS, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->MICROS), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_MICROS = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if (this_object->NANOS == NULL)
            this_object->NANOS = g_object_new (TYPE_NANO_SECONDS, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->NANOS), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_NANOS = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
time_unit_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimeUnit * this_object = TIME_UNIT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimeUnit", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_MILLIS == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "MILLIS", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->MILLIS), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_MICROS == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "MICROS", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->MICROS), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_NANOS == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "NANOS", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->NANOS), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
time_unit_instance_init (TimeUnit * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->MILLIS = NULL;
  object->__isset_MILLIS = FALSE;
  object->MICROS = NULL;
  object->__isset_MICROS = FALSE;
  object->NANOS = NULL;
  object->__isset_NANOS = FALSE;
}

void
time_unit_finalize (GObject *object)
{
  TimeUnit *tobject = TIME_UNIT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->MILLIS != NULL)
  {
    g_object_unref(tobject->MILLIS);
    tobject->MILLIS = NULL;
  }
  if (tobject->MICROS != NULL)
  {
    g_object_unref(tobject->MICROS);
    tobject->MICROS = NULL;
  }
  if (tobject->NANOS != NULL)
  {
    g_object_unref(tobject->NANOS);
    tobject->NANOS = NULL;
  }
}
GType
time_unit_get_type (void)
{
  return G_TYPE_TIME_UNIT;
}

/* reads a timestamp_type object */
gint32
timestamp_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimestampType * this_object = TIMESTAMP_TYPE(object);
  gboolean isset_isAdjustedToUTC = FALSE;
  gboolean isset_unit = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isAdjustedToUTC, error)) < 0)
            return -1;
          xfer += ret;
          isset_isAdjustedToUTC = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if (this_object->unit == NULL)
            this_object->unit = g_object_new (TYPE_TIME_UNIT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->unit), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_unit = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_isAdjustedToUTC)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_unit)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
timestamp_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimestampType * this_object = TIMESTAMP_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimestampType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isAdjustedToUTC", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isAdjustedToUTC, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "unit", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->unit), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
timestamp_type_instance_init (TimestampType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->isAdjustedToUTC = 0;
  object->unit = NULL;
}

void
timestamp_type_finalize (GObject *object)
{
  TimestampType *tobject = TIMESTAMP_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->unit != NULL)
  {
    g_object_unref(tobject->unit);
    tobject->unit = NULL;
  }
}

GType
timestamp_type_get_type (void)
{
  return G_TYPE_TIMESTAMP_TYPE;
}

/* reads a time_type object */
gint32
time_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimeType * this_object = TIME_TYPE(object);
  gboolean isset_isAdjustedToUTC = FALSE;
  gboolean isset_unit = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isAdjustedToUTC, error)) < 0)
            return -1;
          xfer += ret;
          isset_isAdjustedToUTC = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if (this_object->unit == NULL)
            this_object->unit = g_object_new (TYPE_TIME_UNIT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->unit), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_unit = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_isAdjustedToUTC)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_unit)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
time_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimeType * this_object = TIME_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimeType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isAdjustedToUTC", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isAdjustedToUTC, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "unit", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->unit), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
time_type_instance_init (TimeType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->isAdjustedToUTC = 0;
  object->unit = NULL;
}

void
time_type_finalize (GObject *object)
{
  TimeType *tobject = TIME_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->unit != NULL)
  {
    g_object_unref(tobject->unit);
    tobject->unit = NULL;
  }
}

GType
time_type_get_type (void)
{
  return G_TYPE_TIME_TYPE;
}

/* reads a int_type object */
gint32
int_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IntType * this_object = INT_TYPE(object);
  gboolean isset_bitWidth = FALSE;
  gboolean isset_isSigned = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->bitWidth, error)) < 0)
            return -1;
          xfer += ret;
          isset_bitWidth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isSigned, error)) < 0)
            return -1;
          xfer += ret;
          isset_isSigned = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_bitWidth)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_isSigned)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
int_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IntType * this_object = INT_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IntType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bitWidth", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->bitWidth, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isSigned", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isSigned, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
int_type_instance_init (IntType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->bitWidth = 0;
  object->isSigned = 0;
}

void
int_type_finalize (GObject *object)
{
  IntType *tobject = INT_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
int_type_get_type (void)
{
  return G_TYPE_INT_TYPE;
}

/* reads a json_type object */
gint32
json_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  JsonType * this_object = JSON_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
json_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  JsonType * this_object = JSON_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "JsonType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
json_type_instance_init (JsonType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
json_type_finalize (GObject *object)
{
  JsonType *tobject = JSON_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
json_type_get_type (void)
{
  return G_TYPE_JSON_TYPE;
}

/* reads a bson_type object */
gint32
bson_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BsonType * this_object = BSON_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
bson_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BsonType * this_object = BSON_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BsonType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
bson_type_instance_init (BsonType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
bson_type_finalize (GObject *object)
{
  BsonType *tobject = BSON_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
bson_type_get_type (void)
{
  return G_TYPE_BSON_TYPE;
}

/* reads a variant_type object */
gint32
variant_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  VariantType * this_object = VARIANT_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
variant_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  VariantType * this_object = VARIANT_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "VariantType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
variant_type_instance_init (VariantType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
variant_type_finalize (GObject *object)
{
  VariantType *tobject = VARIANT_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
variant_type_get_type (void)
{
  return G_TYPE_VARIANT_TYPE;
}

/* reads a logical_type object */
gint32
logical_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LogicalType * this_object = LOGICAL_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->STRING == NULL)
            this_object->STRING = g_object_new (TYPE_STRING_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->STRING), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_STRING = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if (this_object->MAP == NULL)
            this_object->MAP = g_object_new (TYPE_MAP_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->MAP), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_MAP = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if (this_object->LIST == NULL)
            this_object->LIST = g_object_new (TYPE_LIST_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->LIST), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_LIST = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if (this_object->ENUM == NULL)
            this_object->ENUM = g_object_new (TYPE_ENUM_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ENUM), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ENUM = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if (this_object->DECIMAL == NULL)
            this_object->DECIMAL = g_object_new (TYPE_DECIMAL_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->DECIMAL), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_DECIMAL = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if (this_object->DATE == NULL)
            this_object->DATE = g_object_new (TYPE_DATE_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->DATE), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_DATE = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if (this_object->TIME == NULL)
            this_object->TIME = g_object_new (TYPE_TIME_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->TIME), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_TIME = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if (this_object->TIMESTAMP == NULL)
            this_object->TIMESTAMP = g_object_new (TYPE_TIMESTAMP_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->TIMESTAMP), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_TIMESTAMP = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if (this_object->INTEGER == NULL)
            this_object->INTEGER = g_object_new (TYPE_INT_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->INTEGER), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_INTEGER = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRUCT)
        {
          if (this_object->UNKNOWN == NULL)
            this_object->UNKNOWN = g_object_new (TYPE_NULL_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->UNKNOWN), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_UNKNOWN = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRUCT)
        {
          if (this_object->JSON == NULL)
            this_object->JSON = g_object_new (TYPE_JSON_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->JSON), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_JSON = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_STRUCT)
        {
          if (this_object->BSON == NULL)
            this_object->BSON = g_object_new (TYPE_BSON_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->BSON), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_BSON = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_STRUCT)
        {
          if (this_object->UUID == NULL)
            this_object->UUID = g_object_new (TYPE_U_U_I_D_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->UUID), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_UUID = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_STRUCT)
        {
          if (this_object->FLOAT16 == NULL)
            this_object->FLOAT16 = g_object_new (TYPE_FLOAT16_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->FLOAT16), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_FLOAT16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_STRUCT)
        {
          if (this_object->VARIANT == NULL)
            this_object->VARIANT = g_object_new (TYPE_VARIANT_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->VARIANT), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_VARIANT = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
logical_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LogicalType * this_object = LOGICAL_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LogicalType", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_STRING == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "STRING", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->STRING), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_MAP == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "MAP", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->MAP), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_LIST == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "LIST", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->LIST), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ENUM == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ENUM", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ENUM), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_DECIMAL == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "DECIMAL", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->DECIMAL), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_DATE == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "DATE", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->DATE), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_TIME == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "TIME", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->TIME), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_TIMESTAMP == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "TIMESTAMP", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->TIMESTAMP), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_INTEGER == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "INTEGER", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->INTEGER), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_UNKNOWN == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "UNKNOWN", T_STRUCT, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->UNKNOWN), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_JSON == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "JSON", T_STRUCT, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->JSON), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_BSON == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "BSON", T_STRUCT, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->BSON), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_UUID == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "UUID", T_STRUCT, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->UUID), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_FLOAT16 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "FLOAT16", T_STRUCT, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->FLOAT16), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_VARIANT == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "VARIANT", T_STRUCT, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->VARIANT), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
logical_type_instance_init (LogicalType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->STRING = NULL;
  object->__isset_STRING = FALSE;
  object->MAP = NULL;
  object->__isset_MAP = FALSE;
  object->LIST = NULL;
  object->__isset_LIST = FALSE;
  object->ENUM = NULL;
  object->__isset_ENUM = FALSE;
  object->DECIMAL = NULL;
  object->__isset_DECIMAL = FALSE;
  object->DATE = NULL;
  object->__isset_DATE = FALSE;
  object->TIME = NULL;
  object->__isset_TIME = FALSE;
  object->TIMESTAMP = NULL;
  object->__isset_TIMESTAMP = FALSE;
  object->INTEGER = NULL;
  object->__isset_INTEGER = FALSE;
  object->UNKNOWN = NULL;
  object->__isset_UNKNOWN = FALSE;
  object->JSON = NULL;
  object->__isset_JSON = FALSE;
  object->BSON = NULL;
  object->__isset_BSON = FALSE;
  object->UUID = NULL;
  object->__isset_UUID = FALSE;
  object->FLOAT16 = NULL;
  object->__isset_FLOAT16 = FALSE;
  object->VARIANT = NULL;
  object->__isset_VARIANT = FALSE;
}

void
logical_type_finalize (GObject *object)
{
  LogicalType *tobject = LOGICAL_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->STRING != NULL)
  {
    g_object_unref(tobject->STRING);
    tobject->STRING = NULL;
  }
  if (tobject->MAP != NULL)
  {
    g_object_unref(tobject->MAP);
    tobject->MAP = NULL;
  }
  if (tobject->LIST != NULL)
  {
    g_object_unref(tobject->LIST);
    tobject->LIST = NULL;
  }
  if (tobject->ENUM != NULL)
  {
    g_object_unref(tobject->ENUM);
    tobject->ENUM = NULL;
  }
  if (tobject->DECIMAL != NULL)
  {
    g_object_unref(tobject->DECIMAL);
    tobject->DECIMAL = NULL;
  }
  if (tobject->DATE != NULL)
  {
    g_object_unref(tobject->DATE);
    tobject->DATE = NULL;
  }
  if (tobject->TIME != NULL)
  {
    g_object_unref(tobject->TIME);
    tobject->TIME = NULL;
  }
  if (tobject->TIMESTAMP != NULL)
  {
    g_object_unref(tobject->TIMESTAMP);
    tobject->TIMESTAMP = NULL;
  }
  if (tobject->INTEGER != NULL)
  {
    g_object_unref(tobject->INTEGER);
    tobject->INTEGER = NULL;
  }
  if (tobject->UNKNOWN != NULL)
  {
    g_object_unref(tobject->UNKNOWN);
    tobject->UNKNOWN = NULL;
  }
  if (tobject->JSON != NULL)
  {
    g_object_unref(tobject->JSON);
    tobject->JSON = NULL;
  }
  if (tobject->BSON != NULL)
  {
    g_object_unref(tobject->BSON);
    tobject->BSON = NULL;
  }
  if (tobject->UUID != NULL)
  {
    g_object_unref(tobject->UUID);
    tobject->UUID = NULL;
  }
  if (tobject->FLOAT16 != NULL)
  {
    g_object_unref(tobject->FLOAT16);
    tobject->FLOAT16 = NULL;
  }
  if (tobject->VARIANT != NULL)
  {
    g_object_unref(tobject->VARIANT);
    tobject->VARIANT = NULL;
  }
}
GType
logical_type_get_type (void)
{
  return G_TYPE_LOGICAL_TYPE;
}

/* reads a schema_element object */
gint32
schema_element_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SchemaElement * this_object = SCHEMA_ELEMENT(object);
  gboolean isset_name = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast4;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (Type)ecast4;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type_length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast5;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->repetition_type = (FieldRepetitionType)ecast5;
          this_object->__isset_repetition_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_children, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_num_children = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast6;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->converted_type = (ConvertedType)ecast6;
          this_object->__isset_converted_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->scale, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_scale = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->precision, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_precision = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if (this_object->logicalType == NULL)
            this_object->logicalType = g_object_new (TYPE_LOGICAL_TYPE, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->logicalType), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_logicalType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
schema_element_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SchemaElement * this_object = SCHEMA_ELEMENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaElement", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_type_length == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type_length", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->type_length, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_repetition_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_type", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->repetition_type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_num_children == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "num_children", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_children, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_converted_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "converted_type", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->converted_type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_scale == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "scale", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->scale, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_precision == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "precision", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->precision, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field_id", T_I32, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field_id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_logicalType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "logicalType", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->logicalType), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
schema_element_instance_init (SchemaElement * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->type_length = 0;
  object->__isset_type_length = FALSE;
  object->__isset_repetition_type = FALSE;
  object->name = NULL;
  object->num_children = 0;
  object->__isset_num_children = FALSE;
  object->__isset_converted_type = FALSE;
  object->scale = 0;
  object->__isset_scale = FALSE;
  object->precision = 0;
  object->__isset_precision = FALSE;
  object->field_id = 0;
  object->__isset_field_id = FALSE;
  object->logicalType = NULL;
  object->__isset_logicalType = FALSE;
}

void
schema_element_finalize (GObject *object)
{
  SchemaElement *tobject = SCHEMA_ELEMENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free (tobject->name);
    tobject->name = NULL;
  }
  if (tobject->logicalType != NULL)
  {
    g_object_unref(tobject->logicalType);
    tobject->logicalType = NULL;
  }
}

GType
schema_element_get_type (void)
{
  return G_TYPE_SCHEMA_ELEMENT;
}

/* reads a data_page_header object */
gint32
data_page_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DataPageHeader * this_object = DATA_PAGE_HEADER(object);
  gboolean isset_num_values = FALSE;
  gboolean isset_encoding = FALSE;
  gboolean isset_definition_level_encoding = FALSE;
  gboolean isset_repetition_level_encoding = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_values, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoding = (Encoding)ecast7;
          isset_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->definition_level_encoding = (Encoding)ecast8;
          isset_definition_level_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast9;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast9, error)) < 0)
            return -1;
          xfer += ret;
          this_object->repetition_level_encoding = (Encoding)ecast9;
          isset_repetition_level_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if (this_object->statistics == NULL)
            this_object->statistics = g_object_new (TYPE_STATISTICS, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_num_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_definition_level_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_repetition_level_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
data_page_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DataPageHeader * this_object = DATA_PAGE_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DataPageHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_values", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_values, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encoding", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "definition_level_encoding", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->definition_level_encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_level_encoding", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->repetition_level_encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "statistics", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
data_page_header_instance_init (DataPageHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num_values = 0;
  object->statistics = NULL;
  object->__isset_statistics = FALSE;
}

void
data_page_header_finalize (GObject *object)
{
  DataPageHeader *tobject = DATA_PAGE_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->statistics != NULL)
  {
    g_object_unref(tobject->statistics);
    tobject->statistics = NULL;
  }
}
GType
data_page_header_get_type (void)
{
  return G_TYPE_DATA_PAGE_HEADER;
}

/* reads a index_page_header object */
gint32
index_page_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IndexPageHeader * this_object = INDEX_PAGE_HEADER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
index_page_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IndexPageHeader * this_object = INDEX_PAGE_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IndexPageHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
index_page_header_instance_init (IndexPageHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
index_page_header_finalize (GObject *object)
{
  IndexPageHeader *tobject = INDEX_PAGE_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
index_page_header_get_type (void)
{
  return G_TYPE_INDEX_PAGE_HEADER;
}

/* reads a dictionary_page_header object */
gint32
dictionary_page_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DictionaryPageHeader * this_object = DICTIONARY_PAGE_HEADER(object);
  gboolean isset_num_values = FALSE;
  gboolean isset_encoding = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_values, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast10;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast10, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoding = (Encoding)ecast10;
          isset_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_sorted, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_sorted = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_num_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
dictionary_page_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DictionaryPageHeader * this_object = DICTIONARY_PAGE_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DictionaryPageHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_values", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_values, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encoding", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_is_sorted == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "is_sorted", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->is_sorted, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
dictionary_page_header_instance_init (DictionaryPageHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num_values = 0;
  object->is_sorted = 0;
  object->__isset_is_sorted = FALSE;
}

void
dictionary_page_header_finalize (GObject *object)
{
  DictionaryPageHeader *tobject = DICTIONARY_PAGE_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}
GType
dictionary_page_header_get_type (void)
{
  return G_TYPE_DICTIONARY_PAGE_HEADER;
}

/* reads a data_page_header_v2 object */
gint32
data_page_header_v2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DataPageHeaderV2 * this_object = DATA_PAGE_HEADER_V2(object);
  gboolean isset_num_values = FALSE;
  gboolean isset_num_nulls = FALSE;
  gboolean isset_num_rows = FALSE;
  gboolean isset_encoding = FALSE;
  gboolean isset_definition_levels_byte_length = FALSE;
  gboolean isset_repetition_levels_byte_length = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_values, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_nulls, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_nulls = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_rows, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast11;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast11, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoding = (Encoding)ecast11;
          isset_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->definition_levels_byte_length, error)) < 0)
            return -1;
          xfer += ret;
          isset_definition_levels_byte_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->repetition_levels_byte_length, error)) < 0)
            return -1;
          xfer += ret;
          isset_repetition_levels_byte_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_compressed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_compressed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if (this_object->statistics == NULL)
            this_object->statistics = g_object_new (TYPE_STATISTICS, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_num_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_nulls)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_rows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_definition_levels_byte_length)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_repetition_levels_byte_length)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
data_page_header_v2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DataPageHeaderV2 * this_object = DATA_PAGE_HEADER_V2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DataPageHeaderV2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_values", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_values, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_nulls", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_nulls, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_rows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_rows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encoding", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "definition_levels_byte_length", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->definition_levels_byte_length, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_levels_byte_length", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->repetition_levels_byte_length, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_is_compressed == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "is_compressed", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->is_compressed, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "statistics", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
data_page_header_v2_instance_init (DataPageHeaderV2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num_values = 0;
  object->num_nulls = 0;
  object->num_rows = 0;
  object->definition_levels_byte_length = 0;
  object->repetition_levels_byte_length = 0;
  object->is_compressed = 1;
  object->__isset_is_compressed = FALSE;
  object->statistics = NULL;
  object->__isset_statistics = FALSE;
}

void
data_page_header_v2_finalize (GObject *object)
{
  DataPageHeaderV2 *tobject = DATA_PAGE_HEADER_V2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->statistics != NULL)
  {
    g_object_unref(tobject->statistics);
    tobject->statistics = NULL;
  }
}

GType
data_page_header_v2_get_type (void)
{
  return G_TYPE_DATA_PAGE_HEADER_V2;
}

/* reads a split_block_algorithm object */
gint32
split_block_algorithm_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SplitBlockAlgorithm * this_object = SPLIT_BLOCK_ALGORITHM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
split_block_algorithm_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SplitBlockAlgorithm * this_object = SPLIT_BLOCK_ALGORITHM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SplitBlockAlgorithm", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
split_block_algorithm_instance_init (SplitBlockAlgorithm * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
split_block_algorithm_finalize (GObject *object)
{
  SplitBlockAlgorithm *tobject = SPLIT_BLOCK_ALGORITHM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
split_block_algorithm_get_type (void)
{
  return G_TYPE_SPLIT_BLOCK_ALGORITHM;
}

/* reads a bloom_filter_algorithm object */
gint32
bloom_filter_algorithm_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BloomFilterAlgorithm * this_object = BLOOM_FILTER_ALGORITHM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->BLOCK == NULL)
            this_object->BLOCK = g_object_new (TYPE_SPLIT_BLOCK_ALGORITHM, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->BLOCK), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_BLOCK = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
bloom_filter_algorithm_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BloomFilterAlgorithm * this_object = BLOOM_FILTER_ALGORITHM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BloomFilterAlgorithm", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_BLOCK == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "BLOCK", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->BLOCK), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
bloom_filter_algorithm_instance_init (BloomFilterAlgorithm * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->BLOCK = NULL;
  object->__isset_BLOCK = FALSE;
}

void
bloom_filter_algorithm_finalize (GObject *object)
{
  BloomFilterAlgorithm *tobject = BLOOM_FILTER_ALGORITHM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->BLOCK != NULL)
  {
    g_object_unref(tobject->BLOCK);
    tobject->BLOCK = NULL;
  }
}
GType
bloom_filter_algorithm_get_type (void)
{
  return G_TYPE_BLOOM_FILTER_ALGORITHM;
}

/* reads a xx_hash object */
gint32
xx_hash_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  XxHash * this_object = XX_HASH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
xx_hash_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  XxHash * this_object = XX_HASH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "XxHash", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
xx_hash_instance_init (XxHash * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
xx_hash_finalize (GObject *object)
{
  XxHash *tobject = XX_HASH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
xx_hash_get_type (void)
{
  return G_TYPE_XX_HASH;
}

/* reads a bloom_filter_hash object */
gint32
bloom_filter_hash_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BloomFilterHash * this_object = BLOOM_FILTER_HASH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->XXHASH == NULL)
            this_object->XXHASH = g_object_new (TYPE_XX_HASH, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->XXHASH), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_XXHASH = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
bloom_filter_hash_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BloomFilterHash * this_object = BLOOM_FILTER_HASH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BloomFilterHash", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_XXHASH == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "XXHASH", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->XXHASH), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
bloom_filter_hash_instance_init (BloomFilterHash * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->XXHASH = NULL;
  object->__isset_XXHASH = FALSE;
}

void
bloom_filter_hash_finalize (GObject *object)
{
  BloomFilterHash *tobject = BLOOM_FILTER_HASH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->XXHASH != NULL)
  {
    g_object_unref(tobject->XXHASH);
    tobject->XXHASH = NULL;
  }
}
GType
bloom_filter_hash_get_type (void)
{
  return G_TYPE_BLOOM_FILTER_HASH;
}

/* reads a uncompressed object */
gint32
uncompressed_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Uncompressed * this_object = UNCOMPRESSED(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
uncompressed_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Uncompressed * this_object = UNCOMPRESSED(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Uncompressed", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
uncompressed_instance_init (Uncompressed * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
uncompressed_finalize (GObject *object)
{
  Uncompressed *tobject = UNCOMPRESSED (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
uncompressed_get_type (void)
{
  return G_TYPE_UNCOMPRESSED;
}

/* reads a bloom_filter_compression object */
gint32
bloom_filter_compression_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BloomFilterCompression * this_object = BLOOM_FILTER_COMPRESSION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->UNCOMPRESSED == NULL)
            this_object->UNCOMPRESSED = g_object_new (TYPE_UNCOMPRESSED, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->UNCOMPRESSED), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_UNCOMPRESSED = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
bloom_filter_compression_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BloomFilterCompression * this_object = BLOOM_FILTER_COMPRESSION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BloomFilterCompression", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_UNCOMPRESSED == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "UNCOMPRESSED", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->UNCOMPRESSED), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
bloom_filter_compression_instance_init (BloomFilterCompression * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->UNCOMPRESSED = NULL;
  object->__isset_UNCOMPRESSED = FALSE;
}

void
bloom_filter_compression_finalize (GObject *object)
{
  BloomFilterCompression *tobject = BLOOM_FILTER_COMPRESSION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->UNCOMPRESSED != NULL)
  {
    g_object_unref(tobject->UNCOMPRESSED);
    tobject->UNCOMPRESSED = NULL;
  }
}
GType
bloom_filter_compression_get_type (void)
{
  return G_TYPE_BLOOM_FILTER_COMPRESSION;
}

/* reads a bloom_filter_header object */
gint32
bloom_filter_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BloomFilterHeader * this_object = BLOOM_FILTER_HEADER(object);
  gboolean isset_numBytes = FALSE;
  gboolean isset_algorithm = FALSE;
  gboolean isset_hash = FALSE;
  gboolean isset_compression = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numBytes, error)) < 0)
            return -1;
          xfer += ret;
          isset_numBytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if (this_object->algorithm == NULL)
            this_object->algorithm = g_object_new (TYPE_BLOOM_FILTER_ALGORITHM, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->algorithm), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_algorithm = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if (this_object->hash == NULL)
            this_object->hash = g_object_new (TYPE_BLOOM_FILTER_HASH, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->hash), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_hash = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if (this_object->compression == NULL)
            this_object->compression = g_object_new (TYPE_BLOOM_FILTER_COMPRESSION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->compression), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_compression = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_numBytes)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_algorithm)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_hash)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_compression)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
bloom_filter_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BloomFilterHeader * this_object = BLOOM_FILTER_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BloomFilterHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numBytes", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numBytes, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "algorithm", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->algorithm), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hash", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->hash), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compression", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->compression), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
bloom_filter_header_instance_init (BloomFilterHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->numBytes = 0;
  object->algorithm = NULL;
  object->hash = NULL;
  object->compression = NULL;
}

void
bloom_filter_header_finalize (GObject *object)
{
  BloomFilterHeader *tobject = BLOOM_FILTER_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->algorithm != NULL)
  {
    g_object_unref(tobject->algorithm);
    tobject->algorithm = NULL;
  }
  if (tobject->hash != NULL)
  {
    g_object_unref(tobject->hash);
    tobject->hash = NULL;
  }
  if (tobject->compression != NULL)
  {
    g_object_unref(tobject->compression);
    tobject->compression = NULL;
  }
}

GType
bloom_filter_header_get_type (void)
{
  return G_TYPE_BLOOM_FILTER_HEADER;
}

/* reads a page_header object */
gint32
page_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PageHeader * this_object = PAGE_HEADER(object);
  gboolean isset_type = FALSE;
  gboolean isset_uncompressed_page_size = FALSE;
  gboolean isset_compressed_page_size = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast12;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast12, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (PageType)ecast12;
          isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->uncompressed_page_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_uncompressed_page_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->compressed_page_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_compressed_page_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->crc, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_crc = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          /* On-demand creation */
          if (this_object->data_page_header == NULL)
            this_object->data_page_header = g_object_new (TYPE_DATA_PAGE_HEADER, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data_page_header), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data_page_header = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          /* On-demand creation */
          if (this_object->index_page_header == NULL)
            this_object->index_page_header = g_object_new (TYPE_INDEX_PAGE_HEADER, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->index_page_header), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_index_page_header = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          /* On-demand creation */
          if (this_object->dictionary_page_header == NULL)
            this_object->dictionary_page_header = g_object_new (TYPE_DICTIONARY_PAGE_HEADER, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->dictionary_page_header), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_dictionary_page_header = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          /* On-demand creation */
          if (this_object->data_page_header_v2 == NULL)
            this_object->data_page_header_v2 = g_object_new (TYPE_DATA_PAGE_HEADER_V2, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data_page_header_v2), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data_page_header_v2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_uncompressed_page_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_compressed_page_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
page_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PageHeader * this_object = PAGE_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PageHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "uncompressed_page_size", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->uncompressed_page_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compressed_page_size", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->compressed_page_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_crc == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "crc", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->crc, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_data_page_header == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "data_page_header", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data_page_header), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_index_page_header == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "index_page_header", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->index_page_header), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dictionary_page_header == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dictionary_page_header", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->dictionary_page_header), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_data_page_header_v2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "data_page_header_v2", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data_page_header_v2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
page_header_instance_init (PageHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->uncompressed_page_size = 0;
  object->compressed_page_size = 0;
  object->crc = 0;
  object->__isset_crc = FALSE;
  /*
   * Nested struct is created on-demand
   */
  object->data_page_header = NULL;
  object->__isset_data_page_header = FALSE;
  object->index_page_header = NULL;
  object->__isset_index_page_header = FALSE;
  object->dictionary_page_header = NULL;
  object->__isset_dictionary_page_header = FALSE;
  object->data_page_header_v2 = NULL;
  object->__isset_data_page_header_v2 = FALSE;
}

void
page_header_finalize (GObject *object)
{
  PageHeader *tobject = PAGE_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->data_page_header != NULL)
  {
    g_object_unref(tobject->data_page_header);
    tobject->data_page_header = NULL;
  }
  if (tobject->index_page_header != NULL)
  {
    g_object_unref(tobject->index_page_header);
    tobject->index_page_header = NULL;
  }
  if (tobject->dictionary_page_header != NULL)
  {
    g_object_unref(tobject->dictionary_page_header);
    tobject->dictionary_page_header = NULL;
  }
  if (tobject->data_page_header_v2 != NULL)
  {
    g_object_unref(tobject->data_page_header_v2);
    tobject->data_page_header_v2 = NULL;
  }
}

GType
page_header_get_type (void)
{
  return G_TYPE_PAGE_HEADER;
}

/* reads a key_value object */
gint32
key_value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  KeyValue * this_object = KEY_VALUE(object);
  gboolean isset_key = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_key)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
key_value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  KeyValue * this_object = KEY_VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KeyValue", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
key_value_instance_init (KeyValue * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->value = NULL;
  object->__isset_value = FALSE;
}

void
key_value_finalize (GObject *object)
{
  KeyValue *tobject = KEY_VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free (tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free (tobject->value);
    tobject->value = NULL;
  }
}

GType
key_value_get_type (void)
{
  return G_TYPE_KEY_VALUE;
}

/* reads a sorting_column object */
gint32
sorting_column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SortingColumn * this_object = SORTING_COLUMN(object);
  gboolean isset_column_idx = FALSE;
  gboolean isset_descending = FALSE;
  gboolean isset_nulls_first = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->column_idx, error)) < 0)
            return -1;
          xfer += ret;
          isset_column_idx = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->descending, error)) < 0)
            return -1;
          xfer += ret;
          isset_descending = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->nulls_first, error)) < 0)
            return -1;
          xfer += ret;
          isset_nulls_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_column_idx)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_descending)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_nulls_first)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
sorting_column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SortingColumn * this_object = SORTING_COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SortingColumn", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_idx", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->column_idx, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "descending", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->descending, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nulls_first", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->nulls_first, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
sorting_column_instance_init (SortingColumn * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_idx = 0;
  object->descending = 0;
  object->nulls_first = 0;
}

void
sorting_column_finalize (GObject *object)
{
  SortingColumn *tobject = SORTING_COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}
GType
sorting_column_get_type (void)
{
  return G_TYPE_SORTING_COLUMN;
}

/* reads a page_encoding_stats object */
gint32
page_encoding_stats_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PageEncodingStats * this_object = PAGE_ENCODING_STATS(object);
  gboolean isset_page_type = FALSE;
  gboolean isset_encoding = FALSE;
  gboolean isset_count = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast13;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast13, error)) < 0)
            return -1;
          xfer += ret;
          this_object->page_type = (PageType)ecast13;
          isset_page_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast14;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast14, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoding = (Encoding)ecast14;
          isset_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_page_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_count)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
page_encoding_stats_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PageEncodingStats * this_object = PAGE_ENCODING_STATS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PageEncodingStats", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "page_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->page_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encoding", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
page_encoding_stats_instance_init (PageEncodingStats * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->count = 0;
}

void
page_encoding_stats_finalize (GObject *object)
{
  PageEncodingStats *tobject = PAGE_ENCODING_STATS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}
GType
page_encoding_stats_get_type (void)
{
  return G_TYPE_PAGE_ENCODING_STATS;
}

/* reads a column_meta_data object */
gint32
column_meta_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnMetaData * this_object = COLUMN_META_DATA(object);
  gboolean isset_type = FALSE;
  gboolean isset_encodings = FALSE;
  gboolean isset_path_in_schema = FALSE;
  gboolean isset_codec = FALSE;
  gboolean isset_num_values = FALSE;
  gboolean isset_total_uncompressed_size = FALSE;
  gboolean isset_total_compressed_size = FALSE;
  gboolean isset_data_page_offset = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast15;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast15, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (Type)ecast15;
          isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          if (this_object->encodings == NULL)
            this_object->encodings = g_array_new (0, 1, sizeof (Encoding));
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Encoding* _elem16 = &elem_encoding_read;
              gint32 ecast17;
              if ((ret = thrift_protocol_read_i32 (protocol, &ecast17, error)) < 0)
                return -1;
              xfer += ret;
              *_elem16 = (Encoding)ecast17;
              g_array_append_vals (this_object->encodings, _elem16, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_encodings = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          if (this_object->path_in_schema == NULL)
            this_object->path_in_schema = g_ptr_array_new_with_free_func (g_free);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem18 = NULL;
              if (_elem18 != NULL)
              {
                g_free(_elem18);
                _elem18 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem18, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->path_in_schema, _elem18);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_path_in_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast19;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast19, error)) < 0)
            return -1;
          xfer += ret;
          this_object->codec = (CompressionCodec)ecast19;
          isset_codec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->num_values, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->total_uncompressed_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_total_uncompressed_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->total_compressed_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_total_compressed_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_LIST)
        {
          if (this_object->key_value_metadata == NULL)
            this_object->key_value_metadata = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              KeyValue * _elem20 = NULL;
              if ( _elem20 != NULL)
              {
                g_object_unref (_elem20);
              }
              _elem20 = g_object_new (TYPE_KEY_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem20), protocol, error)) < 0)
              {
                g_object_unref (_elem20);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->key_value_metadata, _elem20);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_key_value_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->data_page_offset, error)) < 0)
            return -1;
          xfer += ret;
          isset_data_page_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->index_page_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_index_page_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->dictionary_page_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_dictionary_page_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRUCT)
        {
          if (this_object->statistics == NULL)
            this_object->statistics = g_object_new (TYPE_STATISTICS, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_LIST)
        {
          if (this_object->encoding_stats == NULL)
            this_object->encoding_stats = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PageEncodingStats * _elem21 = NULL;
              if ( _elem21 != NULL)
              {
                g_object_unref (_elem21);
              }
              _elem21 = g_object_new (TYPE_PAGE_ENCODING_STATS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem21), protocol, error)) < 0)
              {
                g_object_unref (_elem21);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->encoding_stats, _elem21);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_encoding_stats = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->bloom_filter_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bloom_filter_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->bloom_filter_length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bloom_filter_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_STRUCT)
        {
          if (this_object->size_statistics == NULL)
            this_object->size_statistics = g_object_new (TYPE_SIZE_STATISTICS, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->size_statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_size_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encodings)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_path_in_schema)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_codec)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_total_uncompressed_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_total_compressed_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_data_page_offset)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
column_meta_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnMetaData * this_object = COLUMN_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encodings", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i22;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->encodings ? this_object->encodings->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i22 = 0; i22 < (this_object->encodings ? this_object->encodings->len : 0); i22++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (gint32) (g_array_index (this_object->encodings, Encoding, i22)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path_in_schema", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i23;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->path_in_schema ? this_object->path_in_schema->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i23 = 0; i23 < (this_object->path_in_schema ? this_object->path_in_schema->len : 0); i23++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->path_in_schema, i23)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "codec", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->codec, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_values", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->num_values, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "total_uncompressed_size", T_I64, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->total_uncompressed_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "total_compressed_size", T_I64, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->total_compressed_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_value_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_value_metadata", T_LIST, 8, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i24;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i24 = 0; i24 < (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0); i24++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->key_value_metadata, i24))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "data_page_offset", T_I64, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->data_page_offset, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_index_page_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "index_page_offset", T_I64, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->index_page_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dictionary_page_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dictionary_page_offset", T_I64, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->dictionary_page_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "statistics", T_STRUCT, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_encoding_stats == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encoding_stats", T_LIST, 13, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i25;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->encoding_stats ? this_object->encoding_stats->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i25 = 0; i25 < (this_object->encoding_stats ? this_object->encoding_stats->len : 0); i25++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->encoding_stats, i25))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bloom_filter_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bloom_filter_offset", T_I64, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->bloom_filter_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bloom_filter_length == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bloom_filter_length", T_I32, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->bloom_filter_length, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_size_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "size_statistics", T_STRUCT, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->size_statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
column_meta_data_instance_init (ColumnMetaData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->encodings = NULL;
  object->path_in_schema = NULL;
  object->num_values = 0;
  object->total_uncompressed_size = 0;
  object->total_compressed_size = 0;
  object->key_value_metadata = NULL;
  object->__isset_key_value_metadata = FALSE;
  object->data_page_offset = 0;
  object->index_page_offset = 0;
  object->__isset_index_page_offset = FALSE;
  object->dictionary_page_offset = 0;
  object->__isset_dictionary_page_offset = FALSE;
  object->statistics = NULL;
  object->__isset_statistics = FALSE;
  object->encoding_stats = NULL;
  object->__isset_encoding_stats = FALSE;
  object->bloom_filter_offset = 0;
  object->__isset_bloom_filter_offset = FALSE;
  object->bloom_filter_length = 0;
  object->__isset_bloom_filter_length = FALSE;
  object->size_statistics = NULL;
  object->__isset_size_statistics = FALSE;
}

void
column_meta_data_finalize (GObject *object)
{
  ColumnMetaData *tobject = COLUMN_META_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->encodings != NULL)
  {
    g_array_unref (tobject->encodings);
    tobject->encodings = NULL;
  }
  if (tobject->path_in_schema != NULL)
  {
    g_ptr_array_unref (tobject->path_in_schema);
    tobject->path_in_schema = NULL;
  }
  if (tobject->key_value_metadata != NULL)
  {
    g_ptr_array_unref (tobject->key_value_metadata);
    tobject->key_value_metadata = NULL;
  }
  if (tobject->statistics != NULL)
  {
    g_object_unref(tobject->statistics);
    tobject->statistics = NULL;
  }
  if (tobject->encoding_stats != NULL)
  {
    g_ptr_array_unref (tobject->encoding_stats);
    tobject->encoding_stats = NULL;
  }
  if (tobject->size_statistics != NULL)
  {
    g_object_unref(tobject->size_statistics);
    tobject->size_statistics = NULL;
  }
}

GType
column_meta_data_get_type (void)
{
  return G_TYPE_COLUMN_META_DATA;
}

/* reads a encryption_with_footer_key object */
gint32
encryption_with_footer_key_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EncryptionWithFooterKey * this_object = ENCRYPTION_WITH_FOOTER_KEY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
encryption_with_footer_key_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EncryptionWithFooterKey * this_object = ENCRYPTION_WITH_FOOTER_KEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EncryptionWithFooterKey", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
encryption_with_footer_key_instance_init (EncryptionWithFooterKey * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
encryption_with_footer_key_finalize (GObject *object)
{
  EncryptionWithFooterKey *tobject = ENCRYPTION_WITH_FOOTER_KEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
encryption_with_footer_key_get_type (void)
{
  return G_TYPE_ENCRYPTION_WITH_FOOTER_KEY;
}

/* reads a encryption_with_column_key object */
gint32
encryption_with_column_key_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EncryptionWithColumnKey * this_object = ENCRYPTION_WITH_COLUMN_KEY(object);
  gboolean isset_path_in_schema = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          if (this_object->path_in_schema == NULL)
            this_object->path_in_schema = g_ptr_array_new_with_free_func (g_free);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem26 = NULL;
              if (_elem26 != NULL)
              {
                g_free(_elem26);
                _elem26 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem26, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->path_in_schema, _elem26);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_path_in_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->key_metadata != NULL)
          {
            g_free(this_object->key_metadata);
            this_object->key_metadata = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->key_metadata == NULL)
            this_object->key_metadata = g_byte_array_new();
          g_byte_array_append (this_object->key_metadata, (guint8 *) data, (guint) len);
          this_object->__isset_key_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_path_in_schema)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
encryption_with_column_key_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EncryptionWithColumnKey * this_object = ENCRYPTION_WITH_COLUMN_KEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EncryptionWithColumnKey", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path_in_schema", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i27;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->path_in_schema ? this_object->path_in_schema->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i27 = 0; i27 < (this_object->path_in_schema ? this_object->path_in_schema->len : 0); i27++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->path_in_schema, i27)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_metadata", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->key_metadata ? ((GByteArray *) this_object->key_metadata)->data : NULL, this_object->key_metadata ? ((GByteArray *) this_object->key_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
encryption_with_column_key_instance_init (EncryptionWithColumnKey * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path_in_schema = NULL;
  object->key_metadata = NULL;
  object->__isset_key_metadata = FALSE;
}

void
encryption_with_column_key_finalize (GObject *object)
{
  EncryptionWithColumnKey *tobject = ENCRYPTION_WITH_COLUMN_KEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path_in_schema != NULL)
  {
    g_ptr_array_unref (tobject->path_in_schema);
    tobject->path_in_schema = NULL;
  }
  if (tobject->key_metadata != NULL)
  {
    thrift_string_free(tobject->key_metadata);
    tobject->key_metadata = NULL;
  }
}

GType
encryption_with_column_key_get_type (void)
{
  return G_TYPE_ENCRYPTION_WITH_COLUMN_KEY;
}

/* reads a column_crypto_meta_data object */
gint32
column_crypto_meta_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnCryptoMetaData * this_object = COLUMN_CRYPTO_META_DATA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->ENCRYPTION_WITH_FOOTER_KEY == NULL)
            this_object->ENCRYPTION_WITH_FOOTER_KEY = g_object_new (TYPE_ENCRYPTION_WITH_FOOTER_KEY, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ENCRYPTION_WITH_FOOTER_KEY), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ENCRYPTION_WITH_FOOTER_KEY = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if (this_object->ENCRYPTION_WITH_COLUMN_KEY == NULL)
            this_object->ENCRYPTION_WITH_COLUMN_KEY = g_object_new (TYPE_ENCRYPTION_WITH_COLUMN_KEY, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ENCRYPTION_WITH_COLUMN_KEY), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ENCRYPTION_WITH_COLUMN_KEY = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
column_crypto_meta_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnCryptoMetaData * this_object = COLUMN_CRYPTO_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnCryptoMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ENCRYPTION_WITH_FOOTER_KEY == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ENCRYPTION_WITH_FOOTER_KEY", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ENCRYPTION_WITH_FOOTER_KEY), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ENCRYPTION_WITH_COLUMN_KEY == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ENCRYPTION_WITH_COLUMN_KEY", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ENCRYPTION_WITH_COLUMN_KEY), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
column_crypto_meta_data_instance_init (ColumnCryptoMetaData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ENCRYPTION_WITH_FOOTER_KEY = NULL;
  object->__isset_ENCRYPTION_WITH_FOOTER_KEY = FALSE;
  object->ENCRYPTION_WITH_COLUMN_KEY = NULL;
  object->__isset_ENCRYPTION_WITH_COLUMN_KEY = FALSE;
}

void
column_crypto_meta_data_finalize (GObject *object)
{
  ColumnCryptoMetaData *tobject = COLUMN_CRYPTO_META_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ENCRYPTION_WITH_FOOTER_KEY != NULL)
  {
    g_object_unref(tobject->ENCRYPTION_WITH_FOOTER_KEY);
    tobject->ENCRYPTION_WITH_FOOTER_KEY = NULL;
  }
  if (tobject->ENCRYPTION_WITH_COLUMN_KEY != NULL)
  {
    g_object_unref(tobject->ENCRYPTION_WITH_COLUMN_KEY);
    tobject->ENCRYPTION_WITH_COLUMN_KEY = NULL;
  }
}

GType
column_crypto_meta_data_get_type (void)
{
  return G_TYPE_COLUMN_CRYPTO_META_DATA;
}

/* reads a column_chunk object */
gint32
column_chunk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnChunk * this_object = COLUMN_CHUNK(object);
  gboolean isset_file_offset = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->file_path != NULL)
          {
            g_free(this_object->file_path);
            this_object->file_path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->file_path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_file_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->file_offset, error)) < 0)
            return -1;
          xfer += ret;
          isset_file_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if (this_object->meta_data == NULL)
            this_object->meta_data = g_object_new (TYPE_COLUMN_META_DATA, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->meta_data), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_meta_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset_index_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset_index_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->offset_index_length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset_index_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->column_index_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column_index_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->column_index_length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column_index_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if (this_object->crypto_metadata == NULL)
            this_object->crypto_metadata = g_object_new (TYPE_COLUMN_CRYPTO_META_DATA, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->crypto_metadata), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_crypto_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->encrypted_column_metadata != NULL)
          {
            g_free(this_object->encrypted_column_metadata);
            this_object->encrypted_column_metadata = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->encrypted_column_metadata == NULL)
            this_object->encrypted_column_metadata = g_byte_array_new();
          g_byte_array_append (this_object->encrypted_column_metadata, (guint8 *) data, (guint) len);
          this_object->__isset_encrypted_column_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_file_offset)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
column_chunk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnChunk * this_object = COLUMN_CHUNK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnChunk", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_file_path == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "file_path", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->file_path, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "file_offset", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->file_offset, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_meta_data == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "meta_data", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->meta_data), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_offset_index_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset_index_offset", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset_index_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_offset_index_length == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset_index_length", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->offset_index_length, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_index_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_index_offset", T_I64, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->column_index_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_index_length == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_index_length", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->column_index_length, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_crypto_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "crypto_metadata", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->crypto_metadata), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_encrypted_column_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encrypted_column_metadata", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->encrypted_column_metadata ? ((GByteArray *) this_object->encrypted_column_metadata)->data : NULL, this_object->encrypted_column_metadata ? ((GByteArray *) this_object->encrypted_column_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
column_chunk_instance_init (ColumnChunk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->file_path = NULL;
  object->__isset_file_path = FALSE;
  object->file_offset = G_GINT64_CONSTANT (0);
  object->meta_data = NULL;
  object->__isset_meta_data = FALSE;
  object->offset_index_offset = 0;
  object->__isset_offset_index_offset = FALSE;
  object->offset_index_length = 0;
  object->__isset_offset_index_length = FALSE;
  object->column_index_offset = 0;
  object->__isset_column_index_offset = FALSE;
  object->column_index_length = 0;
  object->__isset_column_index_length = FALSE;
  object->crypto_metadata = NULL;
  object->__isset_crypto_metadata = FALSE;
  object->encrypted_column_metadata = NULL;
  object->__isset_encrypted_column_metadata = FALSE;
}

void
column_chunk_finalize (GObject *object)
{
  ColumnChunk *tobject = COLUMN_CHUNK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->file_path != NULL)
  {
    g_free (tobject->file_path);
    tobject->file_path = NULL;
  }
  if (tobject->meta_data != NULL)
  {
    g_object_unref(tobject->meta_data);
    tobject->meta_data = NULL;
  }
  if (tobject->crypto_metadata != NULL)
  {
    g_object_unref(tobject->crypto_metadata);
    tobject->crypto_metadata = NULL;
  }
  if (tobject->encrypted_column_metadata != NULL)
  {
    thrift_string_free(tobject->encrypted_column_metadata);
    tobject->encrypted_column_metadata = NULL;
  }
}
GType
column_chunk_get_type (void)
{
  return G_TYPE_COLUMN_CHUNK;
}

/* reads a row_group object */
gint32
row_group_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RowGroup * this_object = ROW_GROUP(object);
  gboolean isset_columns = FALSE;
  gboolean isset_total_byte_size = FALSE;
  gboolean isset_num_rows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          if (this_object->columns == NULL)
            this_object->columns = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ColumnChunk * _elem28 = NULL;
              if ( _elem28 != NULL)
              {
                g_object_unref (_elem28);
              }
              _elem28 = g_object_new (TYPE_COLUMN_CHUNK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem28), protocol, error)) < 0)
              {
                g_object_unref (_elem28);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem28);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->total_byte_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_total_byte_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->num_rows, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          if (this_object->sorting_columns == NULL)
            this_object->sorting_columns = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              SortingColumn * _elem29 = NULL;
              if ( _elem29 != NULL)
              {
                g_object_unref (_elem29);
              }
              _elem29 = g_object_new (TYPE_SORTING_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem29), protocol, error)) < 0)
              {
                g_object_unref (_elem29);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->sorting_columns, _elem29);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_sorting_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->file_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_file_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->total_compressed_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_total_compressed_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->ordinal, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ordinal = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_columns)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_total_byte_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_rows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
row_group_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RowGroup * this_object = ROW_GROUP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RowGroup", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i30;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i30 = 0; i30 < (this_object->columns ? this_object->columns->len : 0); i30++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i30))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "total_byte_size", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->total_byte_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_rows", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->num_rows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_sorting_columns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sorting_columns", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i31;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->sorting_columns ? this_object->sorting_columns->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i31 = 0; i31 < (this_object->sorting_columns ? this_object->sorting_columns->len : 0); i31++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->sorting_columns, i31))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_file_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "file_offset", T_I64, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->file_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_total_compressed_size == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "total_compressed_size", T_I64, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->total_compressed_size, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ordinal == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ordinal", T_I16, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->ordinal, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
row_group_instance_init (RowGroup * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->columns = NULL;
  object->total_byte_size = 0;
  object->num_rows = 0;
  object->sorting_columns = NULL;
  object->__isset_sorting_columns = FALSE;
  object->file_offset = 0;
  object->__isset_file_offset = FALSE;
  object->total_compressed_size = 0;
  object->__isset_total_compressed_size = FALSE;
  object->ordinal = 0;
  object->__isset_ordinal = FALSE;
}

void
row_group_finalize (GObject *object)
{
  RowGroup *tobject = ROW_GROUP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->sorting_columns != NULL)
  {
    g_ptr_array_unref (tobject->sorting_columns);
    tobject->sorting_columns = NULL;
  }
}
GType
row_group_get_type (void)
{
  return G_TYPE_ROW_GROUP;
}

/* reads a type_defined_order object */
gint32
type_defined_order_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TypeDefinedOrder * this_object = TYPE_DEFINED_ORDER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
type_defined_order_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TypeDefinedOrder * this_object = TYPE_DEFINED_ORDER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TypeDefinedOrder", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
type_defined_order_instance_init (TypeDefinedOrder * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

void
type_defined_order_finalize (GObject *object)
{
  TypeDefinedOrder *tobject = TYPE_DEFINED_ORDER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

GType
type_defined_order_get_type (void)
{
  return G_TYPE_TYPE_DEFINED_ORDER;
}

/* reads a column_order object */
gint32
column_order_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnOrder * this_object = COLUMN_ORDER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->TYPE_ORDER == NULL)
            this_object->TYPE_ORDER = g_object_new (TYPE_TYPE_DEFINED_ORDER, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->TYPE_ORDER), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_TYPE_ORDER = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
column_order_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnOrder * this_object = COLUMN_ORDER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnOrder", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_TYPE_ORDER == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "TYPE_ORDER", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->TYPE_ORDER), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
column_order_instance_init (ColumnOrder * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->TYPE_ORDER = NULL;
  object->__isset_TYPE_ORDER = FALSE;
}

void
column_order_finalize (GObject *object)
{
  ColumnOrder *tobject = COLUMN_ORDER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->TYPE_ORDER != NULL)
  {
    g_object_unref(tobject->TYPE_ORDER);
    tobject->TYPE_ORDER = NULL;
  }
}
GType
column_order_get_type (void)
{
  return G_TYPE_COLUMN_ORDER;
}

/* reads a page_location object */
gint32
page_location_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PageLocation * this_object = PAGE_LOCATION(object);
  gboolean isset_offset = FALSE;
  gboolean isset_compressed_page_size = FALSE;
  gboolean isset_first_row_index = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset, error)) < 0)
            return -1;
          xfer += ret;
          isset_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->compressed_page_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_compressed_page_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->first_row_index, error)) < 0)
            return -1;
          xfer += ret;
          isset_first_row_index = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_offset)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_compressed_page_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_first_row_index)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
page_location_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PageLocation * this_object = PAGE_LOCATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PageLocation", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "offset", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compressed_page_size", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->compressed_page_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first_row_index", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->first_row_index, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
page_location_instance_init (PageLocation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->offset = 0;
  object->compressed_page_size = 0;
  object->first_row_index = 0;
}

void
page_location_finalize (GObject *object)
{
  PageLocation *tobject = PAGE_LOCATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}
GType
page_location_get_type (void)
{
  return G_TYPE_PAGE_LOCATION;
}

/* reads a offset_index object */
gint32
offset_index_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  OffsetIndex * this_object = OFFSET_INDEX(object);
  gboolean isset_page_locations = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          if (this_object->page_locations == NULL)
            this_object->page_locations = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PageLocation * _elem32 = NULL;
              if ( _elem32 != NULL)
              {
                g_object_unref (_elem32);
              }
              _elem32 = g_object_new (TYPE_PAGE_LOCATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem32), protocol, error)) < 0)
              {
                g_object_unref (_elem32);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->page_locations, _elem32);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_page_locations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          if (this_object->unencoded_byte_array_data_bytes == NULL)
            this_object->unencoded_byte_array_data_bytes = g_array_new (0, 1, sizeof (gint64));
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem33 = &elem_i64_read;
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem33, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->unencoded_byte_array_data_bytes, _elem33, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_unencoded_byte_array_data_bytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_page_locations)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
offset_index_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  OffsetIndex * this_object = OFFSET_INDEX(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OffsetIndex", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "page_locations", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i34;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->page_locations ? this_object->page_locations->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i34 = 0; i34 < (this_object->page_locations ? this_object->page_locations->len : 0); i34++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->page_locations, i34))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_unencoded_byte_array_data_bytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "unencoded_byte_array_data_bytes", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i35;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->unencoded_byte_array_data_bytes ? this_object->unencoded_byte_array_data_bytes->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i35 = 0; i35 < (this_object->unencoded_byte_array_data_bytes ? this_object->unencoded_byte_array_data_bytes->len : 0); i35++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->unencoded_byte_array_data_bytes, gint64, i35)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
offset_index_instance_init (OffsetIndex * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->page_locations = NULL;
  object->unencoded_byte_array_data_bytes = NULL;
  object->__isset_unencoded_byte_array_data_bytes = FALSE;
}

void
offset_index_finalize (GObject *object)
{
  OffsetIndex *tobject = OFFSET_INDEX (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->page_locations != NULL)
  {
    g_ptr_array_unref (tobject->page_locations);
    tobject->page_locations = NULL;
  }
  if (tobject->unencoded_byte_array_data_bytes != NULL)
  {
    g_array_unref (tobject->unencoded_byte_array_data_bytes);
    tobject->unencoded_byte_array_data_bytes = NULL;
  }
}

GType
offset_index_get_type (void)
{
  return G_TYPE_OFFSET_INDEX;
}

/* reads a column_index object */
gint32
column_index_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnIndex * this_object = COLUMN_INDEX(object);
  gboolean isset_null_pages = FALSE;
  gboolean isset_min_values = FALSE;
  gboolean isset_max_values = FALSE;
  gboolean isset_boundary_order = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          if (this_object->null_pages == NULL)
            this_object->null_pages = g_array_new (0, 1, sizeof (gboolean));
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gboolean* _elem36 = &elem_bool_read;
              if ((ret = thrift_protocol_read_bool (protocol, &*_elem36, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->null_pages, _elem36, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_null_pages = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          if (this_object->min_values == NULL)
            this_object->min_values = g_ptr_array_new_with_free_func (thrift_string_free);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem37 = NULL;
              if (_elem37 != NULL)
              {
                g_free(_elem37);
                _elem37 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem37 = g_byte_array_new();
              g_byte_array_append (_elem37, (guint8 *) data, (guint) len);
              g_ptr_array_add (this_object->min_values, _elem37);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_min_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          if (this_object->max_values == NULL)
            this_object->max_values = g_ptr_array_new_with_free_func (thrift_string_free);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem38 = NULL;
              if (_elem38 != NULL)
              {
                g_free(_elem38);
                _elem38 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem38 = g_byte_array_new();
              g_byte_array_append (_elem38, (guint8 *) data, (guint) len);
              g_ptr_array_add (this_object->max_values, _elem38);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_max_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast39;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast39, error)) < 0)
            return -1;
          xfer += ret;
          this_object->boundary_order = (BoundaryOrder)ecast39;
          isset_boundary_order = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          if (this_object->null_counts == NULL)
            this_object->null_counts = g_array_new (0, 1, sizeof (gint64));
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem40 = &elem_i64_read;
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem40, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->null_counts, _elem40, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_null_counts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          if (this_object->repetition_level_histograms == NULL)
            this_object->repetition_level_histograms = g_array_new (0, 1, sizeof (gint64));
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem41 = &elem_i64_read;
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem41, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->repetition_level_histograms, _elem41, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_repetition_level_histograms = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          if (this_object->definition_level_histograms == NULL)
            this_object->definition_level_histograms = g_array_new (0, 1, sizeof (gint64));
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem42 = &elem_i64_read;
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem42, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->definition_level_histograms, _elem42, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_definition_level_histograms = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_null_pages)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_min_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_max_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_boundary_order)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
column_index_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnIndex * this_object = COLUMN_INDEX(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnIndex", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "null_pages", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i43;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_BOOL, (gint32) (this_object->null_pages ? this_object->null_pages->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i43 = 0; i43 < (this_object->null_pages ? this_object->null_pages->len : 0); i43++)
    {
      if ((ret = thrift_protocol_write_bool (protocol, (g_array_index (this_object->null_pages, gboolean, i43)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "min_values", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i44;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->min_values ? this_object->min_values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i44 = 0; i44 < (this_object->min_values ? this_object->min_values->len : 0); i44++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->min_values, i44)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->min_values, i44)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->min_values, i44)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->min_values, i44)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "max_values", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i45;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->max_values ? this_object->max_values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i45 = 0; i45 < (this_object->max_values ? this_object->max_values->len : 0); i45++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->max_values, i45)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->max_values, i45)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->max_values, i45)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->max_values, i45)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "boundary_order", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->boundary_order, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_null_counts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "null_counts", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i46;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->null_counts ? this_object->null_counts->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i46 = 0; i46 < (this_object->null_counts ? this_object->null_counts->len : 0); i46++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->null_counts, gint64, i46)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_repetition_level_histograms == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_level_histograms", T_LIST, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i47;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->repetition_level_histograms ? this_object->repetition_level_histograms->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i47 = 0; i47 < (this_object->repetition_level_histograms ? this_object->repetition_level_histograms->len : 0); i47++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->repetition_level_histograms, gint64, i47)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_definition_level_histograms == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "definition_level_histograms", T_LIST, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i48;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->definition_level_histograms ? this_object->definition_level_histograms->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i48 = 0; i48 < (this_object->definition_level_histograms ? this_object->definition_level_histograms->len : 0); i48++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->definition_level_histograms, gint64, i48)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
column_index_instance_init (ColumnIndex * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->null_pages = NULL;
  object->min_values = NULL;
  object->max_values = NULL;
  object->null_counts = NULL;
  object->__isset_null_counts = FALSE;
  object->repetition_level_histograms = NULL;
  object->__isset_repetition_level_histograms = FALSE;
  object->definition_level_histograms = NULL;
  object->__isset_definition_level_histograms = FALSE;
}

void
column_index_finalize (GObject *object)
{
  ColumnIndex *tobject = COLUMN_INDEX (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->null_pages != NULL)
  {
    g_array_unref (tobject->null_pages);
    tobject->null_pages = NULL;
  }
  if (tobject->min_values != NULL)
  {
    g_ptr_array_unref (tobject->min_values);
    tobject->min_values = NULL;
  }
  if (tobject->max_values != NULL)
  {
    g_ptr_array_unref (tobject->max_values);
    tobject->max_values = NULL;
  }
  if (tobject->null_counts != NULL)
  {
    g_array_unref (tobject->null_counts);
    tobject->null_counts = NULL;
  }
  if (tobject->repetition_level_histograms != NULL)
  {
    g_array_unref (tobject->repetition_level_histograms);
    tobject->repetition_level_histograms = NULL;
  }
  if (tobject->definition_level_histograms != NULL)
  {
    g_array_unref (tobject->definition_level_histograms);
    tobject->definition_level_histograms = NULL;
  }
}
GType
column_index_get_type (void)
{
  return G_TYPE_COLUMN_INDEX;
}

/* reads a aes_gcm_v1 object */
gint32
aes_gcm_v1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AesGcmV1 * this_object = AES_GCM_V1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->aad_prefix != NULL)
          {
            g_free(this_object->aad_prefix);
            this_object->aad_prefix = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->aad_prefix == NULL)
            this_object->aad_prefix = g_byte_array_new();
          g_byte_array_append (this_object->aad_prefix, (guint8 *) data, (guint) len);
          this_object->__isset_aad_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->aad_file_unique != NULL)
          {
            g_free(this_object->aad_file_unique);
            this_object->aad_file_unique = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->aad_file_unique == NULL)
            this_object->aad_file_unique = g_byte_array_new();
          g_byte_array_append (this_object->aad_file_unique, (guint8 *) data, (guint) len);
          this_object->__isset_aad_file_unique = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->supply_aad_prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_supply_aad_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
aes_gcm_v1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AesGcmV1 * this_object = AES_GCM_V1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AesGcmV1", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_aad_prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aad_prefix", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->aad_prefix ? ((GByteArray *) this_object->aad_prefix)->data : NULL, this_object->aad_prefix ? ((GByteArray *) this_object->aad_prefix)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_aad_file_unique == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aad_file_unique", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->aad_file_unique ? ((GByteArray *) this_object->aad_file_unique)->data : NULL, this_object->aad_file_unique ? ((GByteArray *) this_object->aad_file_unique)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_supply_aad_prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "supply_aad_prefix", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->supply_aad_prefix, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
aes_gcm_v1_instance_init (AesGcmV1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aad_prefix = NULL;
  object->__isset_aad_prefix = FALSE;
  object->aad_file_unique = NULL;
  object->__isset_aad_file_unique = FALSE;
  object->supply_aad_prefix = 0;
  object->__isset_supply_aad_prefix = FALSE;
}

void
aes_gcm_v1_finalize (GObject *object)
{
  AesGcmV1 *tobject = AES_GCM_V1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aad_prefix != NULL)
  {
    thrift_string_free(tobject->aad_prefix);
    tobject->aad_prefix = NULL;
  }
  if (tobject->aad_file_unique != NULL)
  {
    thrift_string_free(tobject->aad_file_unique);
    tobject->aad_file_unique = NULL;
  }
}
GType
aes_gcm_v1_get_type (void)
{
  return G_TYPE_AES_GCM_V1;
}

/* reads a aes_gcm_ctr_v1 object */
gint32
aes_gcm_ctr_v1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AesGcmCtrV1 * this_object = AES_GCM_CTR_V1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->aad_prefix != NULL)
          {
            g_free(this_object->aad_prefix);
            this_object->aad_prefix = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->aad_prefix == NULL)
            this_object->aad_prefix = g_byte_array_new();
          g_byte_array_append (this_object->aad_prefix, (guint8 *) data, (guint) len);
          this_object->__isset_aad_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->aad_file_unique != NULL)
          {
            g_free(this_object->aad_file_unique);
            this_object->aad_file_unique = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->aad_file_unique == NULL)
            this_object->aad_file_unique = g_byte_array_new();
          g_byte_array_append (this_object->aad_file_unique, (guint8 *) data, (guint) len);
          this_object->__isset_aad_file_unique = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->supply_aad_prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_supply_aad_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
aes_gcm_ctr_v1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AesGcmCtrV1 * this_object = AES_GCM_CTR_V1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AesGcmCtrV1", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_aad_prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aad_prefix", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->aad_prefix ? ((GByteArray *) this_object->aad_prefix)->data : NULL, this_object->aad_prefix ? ((GByteArray *) this_object->aad_prefix)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_aad_file_unique == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aad_file_unique", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->aad_file_unique ? ((GByteArray *) this_object->aad_file_unique)->data : NULL, this_object->aad_file_unique ? ((GByteArray *) this_object->aad_file_unique)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_supply_aad_prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "supply_aad_prefix", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->supply_aad_prefix, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
aes_gcm_ctr_v1_instance_init (AesGcmCtrV1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aad_prefix = NULL;
  object->__isset_aad_prefix = FALSE;
  object->aad_file_unique = NULL;
  object->__isset_aad_file_unique = FALSE;
  object->supply_aad_prefix = 0;
  object->__isset_supply_aad_prefix = FALSE;
}

void
aes_gcm_ctr_v1_finalize (GObject *object)
{
  AesGcmCtrV1 *tobject = AES_GCM_CTR_V1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aad_prefix != NULL)
  {
    thrift_string_free(tobject->aad_prefix);
    tobject->aad_prefix = NULL;
  }
  if (tobject->aad_file_unique != NULL)
  {
    thrift_string_free(tobject->aad_file_unique);
    tobject->aad_file_unique = NULL;
  }
}
GType
aes_gcm_ctr_v1_get_type (void)
{
  return G_TYPE_AES_GCM_CTR_V1;
}

/* reads a encryption_algorithm object */
gint32
encryption_algorithm_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EncryptionAlgorithm * this_object = ENCRYPTION_ALGORITHM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->AES_GCM_V1 == NULL)
            this_object->AES_GCM_V1 = g_object_new (TYPE_AES_GCM_V1, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->AES_GCM_V1), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_AES_GCM_V1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if (this_object->AES_GCM_CTR_V1 == NULL)
            this_object->AES_GCM_CTR_V1 = g_object_new (TYPE_AES_GCM_CTR_V1, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->AES_GCM_CTR_V1), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_AES_GCM_CTR_V1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

gint32
encryption_algorithm_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EncryptionAlgorithm * this_object = ENCRYPTION_ALGORITHM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EncryptionAlgorithm", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_AES_GCM_V1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "AES_GCM_V1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->AES_GCM_V1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_AES_GCM_CTR_V1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "AES_GCM_CTR_V1", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->AES_GCM_CTR_V1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void
encryption_algorithm_instance_init (EncryptionAlgorithm * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->AES_GCM_V1 = NULL;
  object->__isset_AES_GCM_V1 = FALSE;
  object->AES_GCM_CTR_V1 = NULL;
  object->__isset_AES_GCM_CTR_V1 = FALSE;
}

void
encryption_algorithm_finalize (GObject *object)
{
  EncryptionAlgorithm *tobject = ENCRYPTION_ALGORITHM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->AES_GCM_V1 != NULL)
  {
    g_object_unref(tobject->AES_GCM_V1);
    tobject->AES_GCM_V1 = NULL;
  }
  if (tobject->AES_GCM_CTR_V1 != NULL)
  {
    g_object_unref(tobject->AES_GCM_CTR_V1);
    tobject->AES_GCM_CTR_V1 = NULL;
  }
}

GType
encryption_algorithm_get_type (void)
{
  return G_TYPE_ENCRYPTION_ALGORITHM;
}

/* reads a file_meta_data object */
gint32
file_meta_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FileMetaData * this_object = FILE_META_DATA(object);
  gboolean isset_version = FALSE;
  gboolean isset_schema = FALSE;
  gboolean isset_num_rows = FALSE;
  gboolean isset_row_groups = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          if (this_object->schema == NULL)
            this_object->schema = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              SchemaElement * _elem49 = NULL;
              if ( _elem49 != NULL)
              {
                g_object_unref (_elem49);
              }
              _elem49 = g_object_new (TYPE_SCHEMA_ELEMENT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem49), protocol, error)) < 0)
              {
                g_object_unref (_elem49);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->schema, _elem49);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->num_rows, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          if (this_object->row_groups == NULL)
            this_object->row_groups = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              RowGroup * _elem50 = NULL;
              if ( _elem50 != NULL)
              {
                g_object_unref (_elem50);
              }
              _elem50 = g_object_new (TYPE_ROW_GROUP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem50), protocol, error)) < 0)
              {
                g_object_unref (_elem50);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->row_groups, _elem50);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_row_groups = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          if (this_object->key_value_metadata == NULL)
            this_object->key_value_metadata = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              KeyValue * _elem51 = NULL;
              if ( _elem51 != NULL)
              {
                g_object_unref (_elem51);
              }
              _elem51 = g_object_new (TYPE_KEY_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem51), protocol, error)) < 0)
              {
                g_object_unref (_elem51);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->key_value_metadata, _elem51);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_key_value_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->created_by != NULL)
          {
            g_free(this_object->created_by);
            this_object->created_by = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->created_by, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_created_by = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          if (this_object->column_orders == NULL)
            this_object->column_orders = g_ptr_array_new_with_free_func (g_object_unref);
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ColumnOrder * _elem52 = NULL;
              if ( _elem52 != NULL)
              {
                g_object_unref (_elem52);
              }
              _elem52 = g_object_new (TYPE_COLUMN_ORDER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem52), protocol, error)) < 0)
              {
                g_object_unref (_elem52);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->column_orders, _elem52);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_column_orders = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if (this_object->encryption_algorithm == NULL)
            this_object->encryption_algorithm = g_object_new (TYPE_ENCRYPTION_ALGORITHM, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_encryption_algorithm = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->footer_signing_key_metadata != NULL)
          {
            g_free(this_object->footer_signing_key_metadata);
            this_object->footer_signing_key_metadata = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->footer_signing_key_metadata == NULL)
            this_object->footer_signing_key_metadata = g_byte_array_new();
          g_byte_array_append (this_object->footer_signing_key_metadata, (guint8 *) data, (guint) len);
          this_object->__isset_footer_signing_key_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_version)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_schema)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_rows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_row_groups)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
file_meta_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FileMetaData * this_object = FILE_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FileMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->version, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i53;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->schema ? this_object->schema->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i53 = 0; i53 < (this_object->schema ? this_object->schema->len : 0); i53++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->schema, i53))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_rows", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->num_rows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row_groups", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i54;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->row_groups ? this_object->row_groups->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i54 = 0; i54 < (this_object->row_groups ? this_object->row_groups->len : 0); i54++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->row_groups, i54))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_value_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_value_metadata", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i55;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i55 = 0; i55 < (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0); i55++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->key_value_metadata, i55))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_created_by == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "created_by", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->created_by, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_orders == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_orders", T_LIST, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i56;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->column_orders ? this_object->column_orders->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i56 = 0; i56 < (this_object->column_orders ? this_object->column_orders->len : 0); i56++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->column_orders, i56))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_encryption_algorithm == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encryption_algorithm", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_footer_signing_key_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "footer_signing_key_metadata", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->footer_signing_key_metadata ? ((GByteArray *) this_object->footer_signing_key_metadata)->data : NULL, this_object->footer_signing_key_metadata ? ((GByteArray *) this_object->footer_signing_key_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
file_meta_data_instance_init (FileMetaData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->version = 0;
  object->schema = NULL;
  object->num_rows = 0;
  object->row_groups = NULL;
  object->key_value_metadata = NULL;
  object->__isset_key_value_metadata = FALSE;
  object->created_by = NULL;
  object->__isset_created_by = FALSE;
  object->column_orders = NULL;
  object->__isset_column_orders = FALSE;
  object->encryption_algorithm = NULL;
  object->__isset_encryption_algorithm = FALSE;
  object->footer_signing_key_metadata = NULL;
  object->__isset_footer_signing_key_metadata = FALSE;
}

void
file_meta_data_finalize (GObject *object)
{
  FileMetaData *tobject = FILE_META_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_ptr_array_unref (tobject->schema);
    tobject->schema = NULL;
  }
  if (tobject->row_groups != NULL)
  {
    g_ptr_array_unref (tobject->row_groups);
    tobject->row_groups = NULL;
  }
  if (tobject->key_value_metadata != NULL)
  {
    g_ptr_array_unref (tobject->key_value_metadata);
    tobject->key_value_metadata = NULL;
  }
  if (tobject->created_by != NULL)
  {
    g_free (tobject->created_by);
    tobject->created_by = NULL;
  }
  if (tobject->column_orders != NULL)
  {
    g_ptr_array_unref (tobject->column_orders);
    tobject->column_orders = NULL;
  }
  if (tobject->encryption_algorithm != NULL)
  {
    g_object_unref(tobject->encryption_algorithm);
    tobject->encryption_algorithm = NULL;
  }
  if (tobject->footer_signing_key_metadata != NULL)
  {
    thrift_string_free(tobject->footer_signing_key_metadata);
    tobject->footer_signing_key_metadata = NULL;
  }
}
GType
file_meta_data_get_type (void)
{
  return G_TYPE_FILE_META_DATA;
}

/* reads a file_crypto_meta_data object */
gint32
file_crypto_meta_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FileCryptoMetaData * this_object = FILE_CRYPTO_META_DATA(object);
  gboolean isset_encryption_algorithm = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if (this_object->encryption_algorithm == NULL)
            this_object->encryption_algorithm = g_object_new (TYPE_ENCRYPTION_ALGORITHM, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_encryption_algorithm = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->key_metadata != NULL)
          {
            g_free(this_object->key_metadata);
            this_object->key_metadata = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          if (this_object->key_metadata == NULL)
            this_object->key_metadata = g_byte_array_new();
          g_byte_array_append (this_object->key_metadata, (guint8 *) data, (guint) len);
          this_object->__isset_key_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_encryption_algorithm)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
file_crypto_meta_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FileCryptoMetaData * this_object = FILE_CRYPTO_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FileCryptoMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encryption_algorithm", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_metadata", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->key_metadata ? ((GByteArray *) this_object->key_metadata)->data : NULL, this_object->key_metadata ? ((GByteArray *) this_object->key_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
void
file_crypto_meta_data_instance_init (FileCryptoMetaData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->encryption_algorithm = NULL;
  object->key_metadata = NULL;
  object->__isset_key_metadata = FALSE;
}

void
file_crypto_meta_data_finalize (GObject *object)
{
  FileCryptoMetaData *tobject = FILE_CRYPTO_META_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->encryption_algorithm != NULL)
  {
    g_object_unref(tobject->encryption_algorithm);
    tobject->encryption_algorithm = NULL;
  }
  if (tobject->key_metadata != NULL)
  {
    thrift_string_free(tobject->key_metadata);
    tobject->key_metadata = NULL;
  }
}

GType
file_crypto_meta_data_get_type (void)
{
  return G_TYPE_FILE_CRYPTO_META_DATA;
}

/*
 * -----------------------------------------------------------------------------
 * Special functions for FreeBIE repartitioning:
 * To import existing row groups to the new file metadata, we need the functions
 * for (1) extracting row group in byte stream and (2) injecting the byte stream
 * while writing the file metadata.
 * -----------------------------------------------------------------------------
 */
gint32
file_meta_data_read_extract_row_groups_binary (GByteArray **row_groups,
                                               gint32 *num_row_groups,
                                               gint64 *num_rows,
                                               ThriftProtocol *protocol,
                                               GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  gboolean isset_num_rows = FALSE;
  gboolean isset_row_groups = FALSE;

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    /* Skip all except for row_groups */
    switch (fid)
    {
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, num_rows, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;
            goffset row_groups_loc;
            gsize row_groups_size = 0;
            gpointer row_groups_ptr;
            GByteArray *row_groups_binary;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            *num_row_groups = size;
            row_groups_loc = thrift_file_transport_get_location(protocol->transport);

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              if ((ret = thrift_protocol_skip (protocol, T_STRUCT, error)) < 0)
                return -1;
              xfer += ret;
              row_groups_size += ret;
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

            thrift_file_transport_set_location (protocol->transport,
                                                row_groups_loc);
            row_groups_ptr = thrift_file_transport_get_unsafe_ptr (protocol->transport,
                                                                   row_groups_size);
            row_groups_binary = g_byte_array_sized_new (row_groups_size);
            g_byte_array_append (row_groups_binary, row_groups_ptr,
                                 row_groups_size);
            *row_groups = row_groups_binary;
          }
          isset_row_groups = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_num_rows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_row_groups)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

gint32
file_meta_data_write_inject_row_group_binary (ThriftStruct *object,
                                              GByteArray *row_groups,
                                              gint32 num_row_groups,
                                              ThriftProtocol *protocol,
                                              GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FileMetaData * this_object = FILE_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FileMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->version, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i53;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->schema ? this_object->schema->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i53 = 0; i53 < (this_object->schema ? this_object->schema->len : 0); i53++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->schema, i53))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_rows", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->num_rows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row_groups", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i54;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->row_groups ? this_object->row_groups->len + num_row_groups : 0), error)) < 0)
      return -1;
    xfer += ret;
    if (!thrift_transport_write (protocol->transport, row_groups->data, row_groups->len, error))
      return -1;
    xfer += row_groups->len;
    for (i54 = 0; i54 < (this_object->row_groups ? this_object->row_groups->len : 0); i54++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->row_groups, i54))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_value_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_value_metadata", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i55;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i55 = 0; i55 < (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0); i55++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->key_value_metadata, i55))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_created_by == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "created_by", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->created_by, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_orders == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_orders", T_LIST, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i56;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->column_orders ? this_object->column_orders->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i56 = 0; i56 < (this_object->column_orders ? this_object->column_orders->len : 0); i56++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->column_orders, i56))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_encryption_algorithm == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encryption_algorithm", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_footer_signing_key_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "footer_signing_key_metadata", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->footer_signing_key_metadata ? ((GByteArray *) this_object->footer_signing_key_metadata)->data : NULL, this_object->footer_signing_key_metadata ? ((GByteArray *) this_object->footer_signing_key_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}
